<!doctype html>
<title>node_modules for webtreemap</title>
<style>
body {
  font-family: sans-serif;
}
#treemap {
  width: 800px;
  height: 600px;
}
.webtreemap-node {
  cursor: pointer;
  position: absolute;
  border: solid 1px #666;
  box-sizing: border-box;
  overflow: hidden;
  background: white;
  transition: left .15s, top .15s, width .15s, height .15s;
}

.webtreemap-node:hover {
  background: #ddd;
}

.webtreemap-caption {
  font-size: 10px;
  text-align: center;
}
</style>
<div id='treemap'></div>
<script>const data = {"id":"node_modules","size":55890392,"children":[{"id":"typescript","size":42174765,"children":[{"id":"lib","size":42111842,"children":[{"id":"tsserverlibrary.js","size":7309626},{"id":"tsserver.js","size":7291613},{"id":"typescript.js","size":6861211},{"id":"typescriptServices.js","size":6861211},{"id":"typingsInstaller.js","size":5286904},{"id":"tsc.js","size":3913357},{"id":"lib.dom.d.ts","size":694003},{"id":"tsserverlibrary.d.ts","size":414471},{"id":"typescript.d.ts","size":288375},{"id":"typescriptServices.d.ts","size":288361},{"id":"ru/diagnosticMessages.generated.json","size":220294},{"id":"lib.es5.d.ts","size":196217},{"id":"ja/diagnosticMessages.generated.json","size":191480},{"id":"ko/diagnosticMessages.generated.json","size":172839},{"id":"de/diagnosticMessages.generated.json","size":171379},{"id":"fr/diagnosticMessages.generated.json","size":169467},{"id":"pl/diagnosticMessages.generated.json","size":169374},{"id":"it/diagnosticMessages.generated.json","size":169070},{"id":"es/diagnosticMessages.generated.json","size":168273},{"id":"pt-br/diagnosticMessages.generated.json","size":164565},{"id":"tr/diagnosticMessages.generated.json","size":163875},{"id":"cs/diagnosticMessages.generated.json","size":156789},{"id":"zh-cn/diagnosticMessages.generated.json","size":147190},{"id":"diagnosticMessages.generated.json","size":145532},{"id":"zh-tw/diagnosticMessages.generated.json","size":145244},{"id":"lib.webworker.d.ts","size":112164},{"id":"protocol.d.ts","size":87241},{"id":"lib.es2015.core.d.ts","size":19608},{"id":"typesMap.json","size":16786},{"id":"lib.es2015.iterable.d.ts","size":14551},{"id":"lib.es2015.promise.d.ts","size":10652},{"id":"lib.es2015.symbol.wellknown.d.ts","size":10290},{"id":"lib.scripthost.d.ts","size":9462},{"id":"lib.esnext.array.d.ts","size":7686},{"id":"lib.dom.iterable.d.ts","size":6170},{"id":"lib.es2017.sharedmemory.d.ts","size":6148},{"id":"lib.es2016.array.include.d.ts","size":4870},{"id":"cancellationToken.js","size":3029},{"id":"lib.es2015.collection.d.ts","size":2832},{"id":"lib.es2017.object.d.ts","size":2461},{"id":"lib.es2017.string.d.ts","size":2387},{"id":"lib.es2015.generator.d.ts","size":2129},{"id":"lib.es2015.proxy.d.ts","size":1961},{"id":"lib.es2015.reflect.d.ts","size":1913},{"id":"lib.es2018.intl.d.ts","size":1821},{"id":"lib.es2015.symbol.d.ts","size":1657},{"id":"lib.esnext.asynciterable.d.ts","size":1544},{"id":"lib.es2017.typedarrays.d.ts","size":1434},{"id":"lib.es2018.promise.d.ts","size":1361},{"id":"lib.esnext.intl.d.ts","size":1255},{"id":"lib.es2017.intl.d.ts","size":1253},{"id":"lib.es2015.d.ts","size":1250},{"id":"lib.es2018.regexp.d.ts","size":1236},{"id":"watchGuard.js","size":1154},{"id":"lib.es2017.d.ts","size":1092},{"id":"lib.webworker.importscripts.d.ts","size":1051},{"id":"lib.esnext.d.ts","size":1049},{"id":"lib.es6.d.ts","size":1041},{"id":"lib.es2018.full.d.ts","size":1040},{"id":"lib.es2017.full.d.ts","size":1040},{"id":"lib.esnext.full.d.ts","size":1040},{"id":"lib.es2016.full.d.ts","size":1040},{"id":"lib.es2018.d.ts","size":1006},{"id":"lib.esnext.symbol.d.ts","size":1002},{"id":"lib.d.ts","size":1001},{"id":"lib.es2016.d.ts","size":937},{"id":"README.md","size":270}]},{"id":"ThirdPartyNoticeText.txt","size":37767},{"id":"LICENSE.txt","size":9197},{"id":"AUTHORS.md","size":6124},{"id":"README.md","size":4901},{"id":"package.json","size":3572},{"id":"CopyrightNotice.txt","size":819},{"id":"bin","size":223,"children":[{"id":"tsserver","size":50},{"id":"tsc","size":45}]}]},{"id":"prettier","size":8390423,"children":[{"id":"parser-typescript.js","size":2010126},{"id":"parser-flow.js","size":1397777},{"id":"bin-prettier.js","size":1189685},{"id":"index.js","size":1115121},{"id":"parser-postcss.js","size":932038},{"id":"standalone.js","size":731205},{"id":"parser-parse5.js","size":196754},{"id":"parser-babylon.js","size":191544},{"id":"parser-markdown.js","size":159328},{"id":"parser-yaml.js","size":157142},{"id":"parser-glimmer.js","size":138859},{"id":"third-party.js","size":124577},{"id":"parser-graphql.js","size":36059},{"id":"parser-vue.js","size":4097},{"id":"README.md","size":3920},{"id":"LICENSE","size":1054},{"id":"package.json","size":529}]},{"id":"rollup","size":3167219,"children":[{"id":"dist","size":2388622,"children":[{"id":"rollup.es.js","size":772265},{"id":"rollup.js","size":763102},{"id":"rollup.browser.js","size":382441},{"id":"rollup.browser.es.js","size":382208},{"id":"bin/rollup","size":52263},{"id":"shared","size":21002,"children":[{"id":"chunk.js","size":10437},{"id":"index.js","size":10437}]},{"id":"rollup.d.ts","size":15053}]},{"id":"node_modules","size":640836,"children":[{"id":"@types/node","size":640588,"children":[{"id":"fs.d.ts","size":126132},{"id":"inspector.d.ts","size":121692},{"id":"http2.d.ts","size":56517},{"id":"globals.d.ts","size":46765},{"id":"crypto.d.ts","size":29585},{"id":"tls.d.ts","size":21079},{"id":"child_process.d.ts","size":19866},{"id":"repl.d.ts","size":17736},{"id":"stream.d.ts","size":16957},{"id":"http.d.ts","size":16711},{"id":"cluster.d.ts","size":16049},{"id":"dns.d.ts","size":16002},{"id":"zlib.d.ts","size":12194},{"id":"net.d.ts","size":11867},{"id":"util.d.ts","size":11255},{"id":"perf_hooks.d.ts","size":11188},{"id":"constants.d.ts","size":8902},{"id":"worker_threads.d.ts","size":7325},{"id":"readline.d.ts","size":6604},{"id":"package.json","size":6260},{"id":"path.d.ts","size":5932},{"id":"os.d.ts","size":5736},{"id":"async_hooks.d.ts","size":5291},{"id":"index.d.ts","size":4899},{"id":"dgram.d.ts","size":4669},{"id":"vm.d.ts","size":3701},{"id":"url.d.ts","size":3562},{"id":"assert.d.ts","size":2950},{"id":"tty.d.ts","size":2381},{"id":"README.md","size":2349},{"id":"https.d.ts","size":2325},{"id":"trace_events.d.ts","size":2122},{"id":"ts3.2","size":2102,"children":[{"id":"index.d.ts","size":886},{"id":"globals.d.ts","size":640},{"id":"util.d.ts","size":416}]},{"id":"v8.d.ts","size":2010},{"id":"base.d.ts","size":1588},{"id":"events.d.ts","size":1532},{"id":"LICENSE","size":1183},{"id":"querystring.d.ts","size":1117},{"id":"timers.d.ts","size":826},{"id":"buffer.d.ts","size":706},{"id":"domain.d.ts","size":568},{"id":"punycode.d.ts","size":378},{"id":"string_decoder.d.ts","size":185},{"id":"module.d.ts","size":56},{"id":"console.d.ts","size":51},{"id":"process.d.ts","size":51}]},{"id":".bin/acorn","size":120}]},{"id":"CHANGELOG.md","size":123149},{"id":"README.md","size":8482},{"id":"package.json","size":4739},{"id":"LICENSE.md","size":1135}]},{"id":"acorn","size":1103070,"children":[{"id":"dist","size":1077029,"children":[{"id":"acorn.js.map","size":347694},{"id":"acorn.mjs.map","size":347660},{"id":"acorn.js","size":191715},{"id":"acorn.mjs","size":182201},{"id":"acorn.d.ts","size":5212},{"id":"bin.js","size":2291}]},{"id":"CHANGELOG.md","size":13181},{"id":"README.md","size":10558},{"id":"LICENSE","size":1086},{"id":"package.json","size":802},{"id":"bin/acorn","size":158}]},{"id":"@types","size":930179,"children":[{"id":"commander","size":462645,"children":[{"id":"node_modules/@types/node","size":451195,"children":[{"id":"index.d.ts","size":342334},{"id":"inspector.d.ts","size":103577},{"id":"package.json","size":2377},{"id":"README.md","size":1308},{"id":"LICENSE","size":1183}]},{"id":"index.d.ts","size":8503},{"id":"LICENSE","size":1183},{"id":"package.json","size":956},{"id":"README.md","size":584}]},{"id":"node","size":449364,"children":[{"id":"index.d.ts","size":340511},{"id":"inspector.d.ts","size":103577},{"id":"package.json","size":2520},{"id":"README.md","size":1349},{"id":"LICENSE","size":1183}]},{"id":"estree","size":18010,"children":[{"id":"index.d.ts","size":15492},{"id":"LICENSE","size":1183},{"id":"package.json","size":645},{"id":"README.md","size":498}]}]},{"id":"lodash.template","size":50422,"children":[{"id":"index.js","size":47119},{"id":"LICENSE","size":1952},{"id":"package.json","size":692},{"id":"README.md","size":467}]},{"id":"commander","size":45684,"children":[{"id":"index.js","size":25583},{"id":"Readme.md","size":10275},{"id":"History.md","size":7941},{"id":"LICENSE","size":1098},{"id":"package.json","size":563}]},{"id":"lodash.templatesettings","size":13044,"children":[{"id":"index.js","size":9702},{"id":"LICENSE","size":1952},{"id":"package.json","size":675},{"id":"README.md","size":523}]},{"id":"rollup-plugin-banner","size":8622,"children":[{"id":"dist","size":3269,"children":[{"id":"banner.js","size":2594},{"id":"index.js","size":547}]},{"id":"README.md","size":1701},{"id":"package.json","size":1159},{"id":"LICENSE","size":1063},{"id":".eslintrc.js","size":603},{"id":"CHANGELOG.md","size":210},{"id":".travis.yml","size":150},{"id":".editorconfig","size":147}]},{"id":"lodash._reinterpolate","size":3372,"children":[{"id":"LICENSE.txt","size":1239},{"id":"package.json","size":856},{"id":"README.md","size":561},{"id":"index.js","size":524}]},{"id":".yarn-integrity","size":2803},{"id":".bin","size":341,"children":[{"id":"prettier","size":27},{"id":"tsserver","size":26},{"id":"rollup","size":25},{"id":"tsc","size":21},{"id":"acorn","size":18}]}]}</script>
<script>/**
 * webtreemap-cdt
 * v3.0.0
 * https://github.com/paulirish/webtreemap-cdt
 */

var webtreemap = (function (exports) {
    'use strict';

    /**
     * Copyright 2019 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * treeify converts an array of [path, size] pairs into a tree.
     * Paths are /-delimited ids.
     */
    function treeify(data) {
        const tree = { size: 0 };
        for (const [path, size] of data) {
            const parts = path.replace(/\/$/, '').split('/');
            let t = tree;
            while (parts.length > 0) {
                const id = parts.shift();
                if (!t.children)
                    t.children = [];
                let child = t.children.find(c => c.id === id);
                if (!child) {
                    child = { id, size: 0 };
                    t.children.push(child);
                }
                if (parts.length === 0) {
                    if (child.size !== 0) {
                        throw new Error(`duplicate path ${path} ${child.size}`);
                    }
                    child.size = size;
                }
                t = child;
            }
        }
        return tree;
    }
    /**
     * flatten flattens nodes that have only one child.
     * @param join If given, a function that joins the names of the parent and
     * child.
     */
    function flatten(n, join = (parent, child) => `${parent}/${child}`) {
        if (n.children) {
            for (const c of n.children) {
                flatten(c, join);
            }
            if (n.children.length === 1) {
                const child = n.children[0];
                n.id += '/' + child.id;
                n.children = child.children;
            }
        }
    }
    /**
     * rollup fills in the size attribute for nodes by summing their children.
     *
     * Note that it's legal for input data to have a node with a size larger
     * than the sum of its children, perhaps because some data was left out.
     */
    function rollup(n) {
        if (!n.children)
            return;
        let total = 0;
        for (const c of n.children) {
            rollup(c);
            total += c.size;
        }
        if (total > n.size)
            n.size = total;
    }
    /**
     * sort sorts a tree by size, descending.
     */
    function sort(n) {
        if (!n.children)
            return;
        for (const c of n.children) {
            sort(c);
        }
        n.children.sort((a, b) => b.size - a.size);
    }

    /**
     * Copyright 2019 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    const CSS_PREFIX = 'webtreemap-';
    const NODE_CSS_CLASS = CSS_PREFIX + 'node';
    function isDOMNode(e) {
        return e.classList.contains(NODE_CSS_CLASS);
    }
    /**
     * get the index of this node in its parent's children list.
     * O(n) but we expect n to be small.
     */
    function getNodeIndex(target) {
        let index = 0;
        let node = target;
        while ((node = node.previousElementSibling)) {
            if (isDOMNode(node))
                index++;
        }
        return index;
    }
    /**
     * Given a DOM node, compute its address: an array of indexes
     * into the Node tree.  An address [a1,a2,...] refers to
     * tree.chldren[a1].children[a2].children[...].
     */
    function getAddress(el) {
        let address = [];
        let n = el;
        while (n && isDOMNode(n)) {
            address.unshift(getNodeIndex(n));
            n = n.parentElement;
        }
        address.shift(); // The first element will be the root, index 0.
        return address;
    }
    /**
     * Converts a number to a CSS pixel string.
     */
    function px(x) {
        // Rounding when computing pixel coordinates makes the box edges touch
        // better than letting the browser do it, because the browser has lots of
        // heuristics around handling non-integer pixel coordinates.
        return Math.round(x) + 'px';
    }
    function defaultOptions(options) {
        const opts = {
            padding: options.padding || [14, 3, 3, 3],
            caption: options.caption || ((node) => node.id || ''),
            showNode: options.showNode ||
                ((node, width, height) => {
                    return width > 20 && height >= opts.padding[0];
                }),
            showChildren: options.showChildren ||
                ((node, width, height) => {
                    return width > 40 && height > 40;
                }),
        };
        return opts;
    }
    class TreeMap {
        constructor(node, options) {
            this.node = node;
            this.options = defaultOptions(options);
        }
        /** Creates the DOM for a single node if it doesn't have one already. */
        ensureDOM(node) {
            if (node.dom)
                return node.dom;
            const dom = document.createElement('div');
            dom.className = NODE_CSS_CLASS;
            dom.tabIndex = -1;
            if (this.options.caption) {
                const caption = document.createElement('div');
                caption.className = CSS_PREFIX + 'caption';
                caption.innerText = this.options.caption(node);
                dom.appendChild(caption);
            }
            node.dom = dom;
            return dom;
        }
        /**
         * Given a list of sizes, the 1-d space available
         * |space|, and a starting rectangle index |start|, compute a span of
         * rectangles that optimizes a pleasant aspect ratio.
         *
         * Returns [end, sum], where end is one past the last rectangle and sum is the
         * 2-d sum of the rectangles' areas.
         */
        selectSpan(children, space, start) {
            // Add rectangles one by one, stopping when aspect ratios begin to go
            // bad.  Result is [start,end) covering the best run for this span.
            // http://scholar.google.com/scholar?cluster=5972512107845615474
            let smin = children[start].size; // Smallest seen child so far.
            let smax = smin; // Largest child.
            let sum = 0; // Sum of children in this span.
            let lastScore = 0; // Best score yet found.
            let end = start;
            for (; end < children.length; end++) {
                const size = children[end].size;
                if (size < smin)
                    smin = size;
                if (size > smax)
                    smax = size;
                // Compute the relative squariness of the rectangles with this
                // additional rectangle included.
                const nextSum = sum + size;
                // Suppose you're laying out along the x axis, so "space"" is the
                // available width.  Then the height of the span of rectangles is
                //   height = sum/space
                //
                // The largest rectangle potentially will be too wide.
                // Its width and width/height ratio is:
                //   width = smax / height
                //   width/height = (smax / (sum/space)) / (sum/space)
                //                = (smax * space * space) / (sum * sum)
                //
                // The smallest rectangle potentially will be too narrow.
                // Its width and height/width ratio is:
                //   width = smin / height
                //   height/width = (sum/space) / (smin / (sum/space))
                //                = (sum * sum) / (smin * space * space)
                //
                // Take the larger of these two ratios as the measure of the
                // worst non-squarenesss.
                const score = Math.max((smax * space * space) / (nextSum * nextSum), (nextSum * nextSum) / (smin * space * space));
                if (lastScore && score > lastScore) {
                    // Including this additional rectangle produces worse squareness than
                    // without it.  We're done.
                    break;
                }
                lastScore = score;
                sum = nextSum;
            }
            return { end, sum };
        }
        /** Creates and positions child DOM for a node. */
        layoutChildren(node, level, width, height) {
            const total = node.size;
            const children = node.children;
            if (!children)
                return;
            // We use box-sizing: border-box so CSS 'width' etc include the border.
            // With 0 padding we want children to perfectly overlap their parent,
            // so we start with offsets of -1 (to start at the same point as the
            // parent) and create each box 1px larger than necessary (to make
            // adjoining borders overlap).
            let x1 = -1, y1 = -1, x2 = width - 1, y2 = height - 1;
            const spacing = 0; // TODO: this.options.spacing;
            const padding = this.options.padding;
            y1 += padding[0];
            if (padding[1]) {
                // If there's any right-padding, subtract an extra pixel to allow for the
                // boxes being one pixel wider than necessary.
                x2 -= padding[1] + 1;
            }
            y2 -= padding[2];
            x1 += padding[3];
            let i = 0;
            if (this.options.showChildren(node, x2 - x1, y2 - y1)) {
                const scale = Math.sqrt(total / ((x2 - x1) * (y2 - y1)));
                var x = x1, y = y1;
                children: for (let start = 0; start < children.length;) {
                    x = x1;
                    const space = scale * (x2 - x1);
                    const { end, sum } = this.selectSpan(children, space, start);
                    if (sum / total < 0.1)
                        break;
                    const height = sum / space;
                    const heightPx = Math.round(height / scale) + 1;
                    for (i = start; i < end; i++) {
                        const child = children[i];
                        const size = child.size;
                        const width = size / height;
                        const widthPx = Math.round(width / scale) + 1;
                        if (!this.options.showNode(child, widthPx - spacing, heightPx - spacing)) {
                            break children;
                        }
                        const needsAppend = child.dom == null;
                        const dom = this.ensureDOM(child);
                        const style = dom.style;
                        style.left = px(x);
                        style.width = px(widthPx - spacing);
                        style.top = px(y);
                        style.height = px(heightPx - spacing);
                        if (needsAppend) {
                            node.dom.appendChild(dom);
                        }
                        this.layoutChildren(child, level + 1, widthPx, heightPx);
                        // -1 so inner borders overlap.
                        x += widthPx - 1;
                    }
                    // -1 so inner borders overlap.
                    y += heightPx - 1;
                    start = end;
                }
            }
            // Remove the DOM for any children we didn't visit.
            // These can be created if we zoomed in then out.
            for (; i < children.length; i++) {
                if (!children[i].dom)
                    break;
                children[i].dom.parentNode.removeChild(children[i].dom);
                children[i].dom = undefined;
            }
        }
        /**
         * Creates the full treemap in a container element.
         * The treemap is sized to the size of the container.
         */
        render(container) {
            const dom = this.ensureDOM(this.node);
            dom.onclick = e => {
                let node = e.target;
                while (!isDOMNode(node)) {
                    node = node.parentElement;
                    if (!node)
                        return;
                }
                let address = getAddress(node);
                this.zoom(address);
            };
            container.appendChild(dom);
            this.layout(this.node, container);
        }
        layout(node, container) {
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            node.dom.style.width = `${width}px`;
            node.dom.style.height = `${height}px`;
            this.layoutChildren(this.node, 0, width, height);
        }
        /**
         * Zooms the treemap to display a specific node.
         * See getAddress() for a discussion of what address means.
         */
        zoom(address) {
            let node = this.node;
            const [padTop, padRight, padBottom, padLeft] = this.options.padding;
            let width = node.dom.offsetWidth;
            let height = node.dom.offsetHeight;
            for (const index of address) {
                width -= padLeft + padRight;
                height -= padTop + padBottom;
                if (!node.children)
                    throw new Error('bad address');
                for (const c of node.children) {
                    if (c.dom)
                        c.dom.style.zIndex = '0';
                }
                node = node.children[index];
                const style = node.dom.style;
                style.zIndex = '1';
                // See discussion in layout() about positioning.
                style.left = px(padLeft - 1);
                style.width = px(width);
                style.top = px(padTop - 1);
                style.height = px(height);
            }
            this.layoutChildren(node, 0, width, height);
        }
    }
    /** Main entry point; renders a tree into an HTML container. */
    function render(container, node, options) {
        new TreeMap(node, options).render(container);
    }

    exports.TreeMap = TreeMap;
    exports.flatten = flatten;
    exports.getAddress = getAddress;
    exports.isDOMNode = isDOMNode;
    exports.render = render;
    exports.rollup = rollup;
    exports.sort = sort;
    exports.treeify = treeify;

    return exports;

}({}));
</script>
<script>webtreemap.render(document.getElementById("treemap"), data, {
  caption: function humanSizeCaption(n) {
    let units = ['', 'k', 'm', 'g'];
    let unit = 0;
    let size = n.size;
    while (size > 1024 && unit < units.length - 1) {
        size = size / 1024;
        unit++;
    }
    return `${n.id || ''} (${size.toFixed(1)}${units[unit]})`;
},
});</script>

